use std::{collections::{BTreeMap, HashMap, HashSet, VecDeque}, ops::Bound::{Included, Unbounded}, sync::Arc};
use rayon::prelude::*;

const INPUT: &str = "97554,50097
97554,51315
98014,51315
98014,52516
97678,52516
97678,53720
97562,53720
97562,54924
97454,54924
97454,56141
97443,56141
97443,57433
97867,57433
97867,58643
97663,58643
97663,59793
97165,59793
97165,61046
97160,61046
97160,62114
96393,62114
96393,63195
95760,63195
95760,64472
95797,64472
95797,65677
95560,65677
95560,66660
94703,66660
94703,67866
94461,67866
94461,69151
94375,69151
94375,70112
93536,70112
93536,71354
93308,71354
93308,72523
92904,72523
92904,73346
91858,73346
91858,74674
91719,74674
91719,75562
90824,75562
90824,76484
90006,76484
90006,77372
89154,77372
89154,78225
88272,78225
88272,79400
87821,79400
87821,80572
87337,80572
87337,81102
86079,81102
86079,82070
85350,82070
85350,83377
84968,83377
84968,83848
83709,83848
83709,84872
83012,84872
83012,85506
81946,85506
81946,86280
81016,86280
81016,87071
80101,87071
80101,88296
79517,88296
79517,88974
78496,88974
78496,89787
77571,89787
77571,89907
76184,89907
76184,90672
75235,90672
75235,91328
74214,91328
74214,92452
73448,92452
73448,92967
72332,92967
72332,92998
70982,92998
70982,93802
70016,93802
70016,94188
68855,94188
68855,95017
67874,95017
67874,94789
66483,94789
66483,95209
65349,95209
65349,95513
64177,95513
64177,96629
63238,96629
63238,96077
61829,96077
61829,97183
60847,97183
60847,96805
59518,96805
59518,97644
58438,97644
58438,97281
57143,97281
57143,98074
56022,98074
56022,98014
54782,98014
54782,97822
53542,97822
53542,98029
52336,98029
52336,97710
51110,97710
51110,97772
49901,97772
49901,97810
48690,97810
48690,97778
47478,97778
47478,97982
46246,97982
46246,97836
45036,97836
45036,97966
43790,97966
43790,97134
42679,97134
42679,96886
41496,96886
41496,97245
40189,97245
40189,96899
39015,96899
39015,96391
37886,96391
37886,95981
36740,95981
36740,95415
35648,95415
35648,95453
34359,95453
34359,95388
33083,95388
33083,94436
32143,94436
32143,93943
31035,93943
31035,93861
29737,93861
29737,92960
28817,92960
28817,92308
27788,92308
27788,91659
26764,91659
26764,91091
25697,91091
25697,90770
24471,90770
24471,89993
23524,89993
23524,89445
22424,89445
22424,88292
21760,88292
21760,88028
20438,88028
20438,86932
19758,86932
19758,86697
18364,86697
18364,85527
17769,85527
17769,84637
16938,84637
16938,84037
15822,84037
15822,83289
14834,83289
14834,82355
14039,82355
14039,81370
13304,81370
13304,80141
12878,80141
12878,79366
11899,79366
11899,78188
11447,78188
11447,77518
10289,77518
10289,76071
10264,76071
10264,75346
9148,75346
9148,74272
8572,74272
8572,73252
7903,73252
7903,71993
7683,71993
7683,70973
7020,70973
7020,70099
6017,70099
6017,68658
6273,68658
6273,67811
5141,67811
5141,66686
4658,66686
4658,65554
4186,65554
4186,64280
4154,64280
4154,62980
4279,62980
4279,61865
3780,61865
3780,60837
2857,60837
2857,59526
3153,59526
3153,58362
2784,58362
2784,57122
2862,57122
2862,55976
2293,55976
2293,54744
2372,54744
2372,53555
2006,53555
2006,52309
2532,52309
2532,51107
2444,51107
2444,50092
94969,50092
94969,48695
2401,48695
2401,47472
2104,47472
2104,46252
2085,46252
2085,45003
1851,45003
1851,43782
1972,43782
1972,42619
2475,42619
2475,41499
3127,41499
3127,40291
3243,40291
3243,39002
3045,39002
3045,37965
3910,37965
3910,36635
3654,36635
3654,35484
4066,35484
4066,34375
4595,34375
4595,33191
4899,33191
4899,32088
5426,32088
5426,31024
6031,31024
6031,29902
6495,29902
6495,28970
7349,28970
7349,27865
7837,27865
7837,26540
7938,26540
7938,25396
8400,25396
8400,24455
9204,24455
9204,23410
9835,23410
9835,22302
10380,22302
10380,21288
11067,21288
11067,20614
12197,20614
12197,19773
13085,19773
13085,18432
13380,18432
13380,18035
14766,18035
14766,16934
15358,16934
15358,15640
15781,15640
15781,15007
16873,15007
16873,14377
17948,14377
17948,13406
18715,13406
18715,13059
20005,13059
20005,12026
20730,12026
20730,11146
21591,11146
21591,10877
22889,10877
22889,9597
23491,9597
23491,9204
24688,9204
24688,8511
25691,8511
25691,7961
26779,7961
26779,7620
27973,7620
27973,7094
29063,7094
29063,6213
29990,6213
29990,5806
31142,5806
31142,5524
32340,5524
32340,5390
33582,5390
33582,4535
34564,4535
34564,3850
35624,3850
35624,3701
36855,3701
36855,3240
37995,3240
37995,3213
39244,3213
39244,3179
40478,3179
40478,2611
41607,2611
41607,2772
42864,2772
42864,2453
44043,2453
44043,1887
45207,1887
45207,1722
46423,1722
46423,2230
47675,2230
47675,2048
48883,2048
48883,2246
50098,2246
50098,1571
51326,1571
51326,2506
52506,2506
52506,2131
53744,2131
53744,2091
54971,2091
54971,2492
56149,2492
56149,2240
57417,2240
57417,2780
58563,2780
58563,3252
59707,3252
59707,2784
61058,2784
61058,3616
62111,3616
62111,4174
63214,4174
63214,4505
64376,4505
64376,4881
65525,4881
65525,4805
66844,4805
66844,5390
67925,5390
67925,5871
69044,5871
69044,6508
70091,6508
70091,7082
71161,7082
71161,7383
72372,7383
72372,7768
73554,7768
73554,9102
74188,9102
74188,9667
75254,9667
75254,9797
76614,9797
76614,10885
77343,10885
77343,10986
78771,10986
78771,12172
79404,12172
79404,12916
80365,12916
80365,13813
81194,13813
81194,14486
82217,14486
82217,15240
83178,15240
83178,16006
84134,16006
84134,16700
85175,16700
85175,17847
85735,17847
85735,18583
86748,18583
86748,19883
87090,19883
87090,20735
87968,20735
87968,21578
88871,21578
88871,22661
89450,22661
89450,23904
89772,23904
89772,24673
90819,24673
90819,25505
91806,25505
91806,26583
92392,26583
92392,27997
92332,27997
92332,29143
92741,29143
92741,29843
94107,29843
94107,31349
93707,31349
93707,32466
94157,32466
94157,33386
95143,33386
95143,34684
95110,34684
95110,35786
95628,35786
95628,36908
96109,36908
96109,37966
96874,37966
96874,39340
96368,39340
96368,40395
97227,40395
97227,41701
96853,41701
96853,42896
97012,42896
97012,44034
97623,44034
97623,45212
98064,45212
98064,46468
97674,46468
97674,47665
97990,47665
97990,48888
97735,48888
97735,50097";

// const INPUT: &str = "7,1
// 11,1
// 11,7
// 9,7
// 9,5
// 2,5
// 2,3
// 7,3";

fn area(a: (u64, u64), b: (u64, u64)) -> u64 {
    (a.0.abs_diff(b.0) + 1) * (a.1.abs_diff(b.1) + 1)
}

// for the rectangle (u, v) to fall inside the perimeter points P',
//   (u.x, v.y), (v.x, u.y) must fall within space bounded by P' (correct when shape is convex)
//   we can traverse from any points without exiting (additional check for non convex)


fn main() {
    let points: Vec<(u64, u64)> = INPUT.split("\n")
        .map(|s| {
            let mut a = s.split(",").map(|d| d.parse().unwrap());
            (a.next().unwrap(), a.next().unwrap())
        }).collect();
    let points = Arc::new(points);
    
    let mut p1 = 0;
    for i in 0..points.len() {
        for v in i..points.len() {
            let a = points[i];
            let b = points[v];
            let area = area(a, b);
            p1 = p1.max(area);
        }
    }
        
    // min/max at each coord (extreme points)
    let mut x_aligned: BTreeMap<u64, (u64, u64)> = BTreeMap::new();
    let mut y_aligned: BTreeMap<u64, (u64, u64)> = BTreeMap::new();
    for (x, y) in points.iter().copied() {
        if let Some((min, max)) = x_aligned.get_mut(&x) {
            *min = (*min).min(y);
            *max = (*max).max(y);
        } else {
            x_aligned.insert(x, (y, y));
        }
        if let Some((min, max)) = y_aligned.get_mut(&y) {
            *min = (*min).min(x);
            *max = (*max).max(x);
        } else {
            y_aligned.insert(y, (x, x));
        }
    }
    
    macro_rules! bounded {
        ($alignment: expr, $axis: expr, $cmp_axis: expr, $out: expr, $upper_bound: expr) => {
            if $upper_bound {
                for (_, (low, high)) in $alignment.range((Unbounded, Included(&$axis))).rev() {
                    bounded!($axis, $cmp_axis, $out, low, high, ())
                }
            } else {
                for (_, (low, high)) in $alignment.range((Included(&$axis), Unbounded)) {
                    bounded!($axis, $cmp_axis, $out, low, high, ())
                }
            }
        };
        ($axis: expr, $cmp_axis: expr, $out: expr, $low: expr, $high: expr, $_: expr) => {
            if (*$low..=*$high).contains(&$cmp_axis) {
                $out = Some($axis);
                break;
            }
        };
    }

    let is_contained = |(x, y): (u64, u64)| {
        let mut left = None;
        let mut right = None;
        let mut top = None;
        let mut bottom = None;
        bounded!(x_aligned, x, y, left, true);
        bounded!(y_aligned, y, x, bottom, true);
        bounded!(x_aligned, x, y, right, false);
        bounded!(y_aligned, y, x, top, false);
        (left.is_some() && right.is_some() && top.is_some() && bottom.is_some()).then(|| (left.unwrap(), right.unwrap(), top.unwrap(), bottom.unwrap()))
    };
    
    // whatever lol this is slow as hell idc anymore
    let point_is_reachable = |(x, y): (u64, u64), (tx, ty): (u64, u64)| {
        let dx = (tx as i32 - x as i32).clamp(-1, 1);
        let dy = (ty as i32 - y as i32).clamp(-1, 1);
        let mut pos = ((x as i32 + dx) as u64, (y as i32 + dy) as u64);
        loop {
            let (nx, ny) = pos;
            let Some((left, right, top, bottom)) = is_contained((nx as _, ny as _)) else { return false };
            let next = if dx < 0 { if left <= tx { return true; } (left - 1, ny) }
                else if dx > 0 { if right >= tx { return true; } (right + 1, ny) }
                else if dy < 0 { if bottom <= ty { return true; } (nx, bottom - 1) }
                else { if top >= ty { return true; } (nx, top + 1) };
            pos = next;
        }
    };
    
    // bought my multi core cpu so im gonna use the whole cpu
    let p2 = (0..points.len()).into_par_iter()
        .flat_map(|i| {
            let points = points.clone();
            (i+1..points.len()).into_par_iter()
                .map(move |v| {
                    let a = points[i].clone();
                    let b = points[v].clone();

                    // check if point lies in P': find closest top, bottom, left, right edges containing this point
                    let c1 = (a.0, b.1);
                    let c2 = (b.0, a.1);
                    if is_contained(c1).is_some() && is_contained(c2).is_some() {
                        // traverse until we reach this point, if we ever exit the shape, invalid (non-convex)
                        if point_is_reachable(a, c1) && point_is_reachable(a, c2) && point_is_reachable(b, c1) && point_is_reachable(b, c2) {
                            let area = area(a, b);
                            return Some(area);
                        }
                    }
                    return None;
                })
        }).filter_map(|r| r).max();
    
    println!("part 1: {p1}");
    println!("part 2: {}", p2.unwrap());
}